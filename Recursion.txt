Recursion

Recursion --> 자기 자신을 호출하는 함수 (재귀함수)

자기자신을 호출하는 함수

void func() {
	func()	// 자기자신을 호출
}

재귀함수는 조건이 없을 시 무한 루프에 빠지게 됨
재귀함수는 조건이 있어야 함

어떤 함수가 return 있을 시 호출한 다음 문장으로 넘어감
ㅠ
조건에서 다시 recursion 으로 돌아가지 않는 곳이 있어야 함수

Base Case : 적어도 하나의 Recursion에 빠지지 않는 경우가 존재하여야 함
Recursive Case : Recursion 을 반복하다보면 결국 BaseCase 로 수렴해야 함

Recursive Function 은 수학적 귀납법과 동일

// 피보나치 수열
피보나치 수열은 자기 전의 항과 전전의 항의 합과 동일

객체지향 프로그래밍 --> 프로그램은 객체들간의 상호 작용

Recursive Function --> 수함함수뿐 아니라 다른 많은 문제들을 recursion 으로 해결할 수 있다

for 문이나 while 문을 사용하는대 신 recursion 을 활용하여 해결도 가능

모든 순환함수는 반복문(iteration) 으로 변경이 가능함
그 역도 성립함, 즉 모든 반복문은 recursion 으로 표현 가능
순환함수는 복잡한 알고리즘을 단순하고 알기쉽게 표현하는것을 가능케 함
하지만 함수 호출에 따른 오버헤드가 있음 (매개변수 전달, 엑티베이션 프레임 생성 등)

반복문에 비해 Recursion 은 프로그램 실행속도면에서 손해를 보게 됨 (Recursion 을 남용하면 안됨)
Recursion 단점은 계속해서 함수를 호출하게 되므로 오버헤드가 있음 (매개변수 전달, 시스템 스택, 액티베이션 프레임 생성등 .. )

Recursion 설계하는 방법 .... 
Recursion 은 적어도 하나의 base case, 즉 순환 되지않고 종료되는 case 가 있어야 함
모든 case 는 결국 base case 로 수렴해야 함 
base case 가 없을 시 무한 루프에 걸리게 됨(Recursion 이 자기자신을 항상 호출하게 됨)

Recursion 이 복잡하여 질수록 적어도 하나의 base case 가 존재
모든 case 들이 반복되다 보면 모든 case 가 base case 로 수렴

암시적(implicit) 매개변수를 명시적(explictit) 매개변수로 바꾸어라 
(만약 배열 [0, n-1] index 0 부터 n-1 까지 사이에서 target(찾을 수) 을 검색, 예를 들어 함수에서 매개변수로 시작점을 표현하지 않고, 끝에만 n 이라고 펴표현을 해주지만
하지만 Recursion 프로그래밍 시에는 일반적으로 시작 매개변수도 넣어주는 것이 좋음 이것이 명시적 매개변수로 바꾸는 과정) 
크기대로 정렬되어있다면 순차검색 대신 이진검색이 가능

근데 만약에 데이터들이 정렬되어있지 않다면 어떤 특별한 조건이나 그런것들이 존재하지 않을 시 
이 배열안에 이 값이 있는지 찾는 방법은 하나씩 확인하는 방법밖에 없음 (순차적으로 검사)
순차 sequential search 검색 / 이진 binary 검색 

순차검색은 뒤에서 부터 검사를 하여도되고 뒤에서부터 검사를해도 됨

이진 검색 --> 기본적으로 이진검색은 데이터가 크기순으로 정렬되어있음 (크기순으로 정렬시에 적용 가능)
가운데 데이터를 찾는 값과 비교, 가운데 값 보다 크다면 뒤에값들이 더 크므로 뒤에만 탐색
가운데 값 보다 작다면 앞에값들이 가운다 뒤에값보다 작으므로 앞메만 탐색 
compareTo 메서드를 이용하여 작으면 음수 똑같을 시 0 크면 1 을 return 

------ 미로찾기
가본곳과 안가본곳을 구분하기 구분하지 않으면 무한루프에 빠질 수 있음
내가 가본곳과 안가본곳을 구분을 하여야 함
























